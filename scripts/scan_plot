#!/usr/bin/env python2.7
"""
Scans a particular operating parameter across its range of values and writs a plot to a file
"""


def plot_data_to_pdf(parameter_name, measurement_data, filename=None):
    """
    Plot measurements to a file
    :param parameter_name: The name of the parameter being measure
    :param measurement_data: A dictionary of parameter set values and measurements
    :param filename: An optional filename to write to
    :return: The name of the filename the plot was written to
    """
    import matplotlib.pyplot as plt
    import pylab
    from matplotlib.backends.backend_pdf import PdfPages
    import datetime
    import os.path
    # Flatten measurements data into something less natural for matplotlib...
    if filename is None:
        filename = parameter_name + ".pdf"
    _, extension = os.path.splitext(filename)
    if extension is not ".pdf":
        filename += ".pdf"
    basename, _ = os.path.splitext(filename)
    count = 0
    while os.path.exists(filename):
        filename = "{basename}.{count}.pdf".format(basename=basename, count=count)
        count += 1
    with PdfPages(filename) as pdf:
        x = [k for k in measurement_data
             for _ in measurement_data[k]]
        y = [d for k in measurement_data
             for d in measurement_data[k]]
        ran = [min(x + y) - 1, max(x + y) + 1]
        pylab.ylim(ran)
        pylab.xlim(ran)
        plt.axes().set_aspect(1)
        plt.scatter(x, y, color='red')
        pylab.grid(True)
        min_value, max_value = ran
        plt.plot(np.arange(min_value, max_value + 1),
                 np.arange(min_value, max_value + 1))
        plt.title(parameter_name)
        # Makes some assumptions about measurement_data, be careful!
        sorted_keys = list(sorted(measurements.keys()))
        calculated_step_size = sorted_keys[1] - sorted_keys[0]
        samples_per_step = len(measurement_data[measurement_data.keys()[0]])
        pdf_information = pdf.infodict()
        pdf_information['Title'] = "Plot of {parameter_name}".format(parameter_name=parameter_name)
        pdf_information['Parameter'] = parameter_name
        pdf_information['Minimum'] = min(x)
        pdf_information['Maximum'] = max(x)
        pdf_information['StepSize'] = calculated_step_size
        pdf_information['SamplesPerStep'] = samples_per_step
        pdf_information['CreationDate'] = datetime.datetime.today()
        pdf.savefig()
        plt.close()
    return filename


if __name__ == "__main__":
    from tessfpe.dhu.fpe import FPE
    import argparse
    import numpy as np

    parser = argparse.ArgumentParser(description='Scan an operating parameter and plot the result to a file')
    parser.add_argument('parameter', type=str, help="The name of the operating parameter to scan")
    parser.add_argument('low_value', type=float, nargs='?', default=None,
                        help="The low value to start the scan at, "
                             "defaults to the lowest possible value the parameter can be")
    parser.add_argument('high_value', type=float, nargs='?', default=None,
                        help="The high value to stop the scan at,"
                             " defaults to the highest possible value the parameter can be")
    parser.add_argument('--FPE-number', metavar='N', type=int, nargs='?', default=1, help='which FPE to use')
    parser.add_argument('--output', type=str, nargs='?', default=None,
                        help="The file where the of the results should be output; defaults to "
                             "<parameter>.pdf or <parameter>.<number>.pdf")
    parser.add_argument('--steps', metavar='N', type=int, nargs='?', default=100,
                        help='The number of steps to take as the operating parameter is walked from its low value '
                             'to its high value (default is 100)')
    parser.add_argument('--step-size', metavar='N', type=int, nargs='?', default=None,
                        help="The size of a step to take as the operating parameter is walked from its low value "
                             "to its high value; overrides '--steps'")
    parser.add_argument('--samples-per-step', metavar='N', type=int, nargs='?', default=5,
                        help="The number of samples to take for each value the operating parameter is stepped to "
                             "(default is 5)")
    parser.add_argument('--set-defaults', action='store_true',
                        help='Set the operating parameters to their default values before running the scan')

    args = parser.parse_args()

    step_size = args.step_size if args.step_size is not None \
        else np.abs(args.low_value - args.high_value) / args.steps

    with FPE(args.FPE_number) as fpe:
        frames_status = None
        old_values = None
        try:
            frames_status = fpe.frames_running_status
            fpe.frames_running_status = False
            old_values = fpe.ops.values
            assert args.parameter in old_values, "Unknown operating parameter: {}".format(args.parameter)
            assert args.parameter in fpe.house_keeping["analogue"], \
                "Parameter doesn't correspond to any known housekeeping value: {}".format(args.parameter)
            if args.set_defaults is True:
                fpe.ops.reset_to_defaults()
            measurements = {}
            for value in np.arange(args.low_value, args.high_value, step_size):
                fpe.ops[args.parameter] = value
                fpe.ops.send()
                measurements[value] = [fpe.house_keeping["analogue"][args.parameter]
                                       for _ in range(args.samples_per_step)]
            print "Wrote {}".format(plot_data_to_pdf(args.parameter, measurements, filename=args.output))
        finally:
            if old_values is not None:
                for parameter in old_values:
                    if parameter + "_offset" not in old_values:
                        fpe.ops[parameter] = old_values[parameter]
                fpe.ops.send()
            if frames_status is not None:
                fpe.frames_running_status = frames_status
